/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-screen-capture.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : screen-capture
 #	author : miyako
 #	2020/08/13
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-screen-capture.h"

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
			// --- screen-capture
            
			case 1 :
				Capture_screen(params);
				break;
			case 2 :
				Capture_window(params);
				break;

        }

	}
	catch(...)
	{

	}
}

#pragma mark -

#if VERSIONMAC
NSWindow *PA_GetWindowRef64(int winId)
{
    //EX_GET_HWND has been fixed in 15R3 to return a NSWindow* on mac 64bit.
    //http://forums.4d.fr/Post/EN/15872830/1/17032044
    
    PA_ulong32 version = (PA_Get4DVersion() & 0x0000FFFF);
    //    int minor = version & 0x000F;
    int r = (version & 0x00F0) >> 4;
    int major = (version & 0xFF00) >> 8;
    if (((major >=0x15) && (r >= 3)) || (major >=0x16))
    {
        return (NSWindow *)PA_GetWindowPtr(reinterpret_cast<NSWindow *>(winId));
    }
    return 0;
}
CGWindowID getWindowId(PA_long32 arg)
{
#if CGFLOAT_IS_DOUBLE
    NSWindow *window = PA_GetWindowRef64(arg);
    return window ? [window windowNumber] : kCGNullWindowID;
#else
    return HIWindowGetCGWindowID(reinterpret_cast<WindowRef>(PA_GetWindowPtr(reinterpret_cast<PA_WindowRef>(arg))));
#endif
}

void getWindowImage(CGWindowID windowId, CGWindowListOption option, PA_PluginParameters params)
{
    CGImageRef image = CGWindowListCreateImage(CGRectNull,
                                                                                         option,
                                                                                         windowId,
                                                                                         kCGWindowImageBoundsIgnoreFraming);
    if(image)
    {
        CFMutableDataRef data = CFDataCreateMutable(kCFAllocatorDefault, 0);
        CGImageDestinationRef destination = CGImageDestinationCreateWithData(data, kUTTypeTIFF, 1, NULL);
        CFMutableDictionaryRef properties = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, NULL, NULL);
        CGImageDestinationAddImage(destination, image, properties);
        CGImageDestinationFinalize(destination);

        PA_Picture p = PA_CreatePicture((void *)CFDataGetBytePtr(data), CFDataGetLength(data));
        PA_ReturnPicture(params, p);

        CFRelease(destination);
        CFRelease(properties);
        CFRelease(data);

        CGImageRelease(image);
    }
}
#else
void captureWindow(HBITMAP hbmWindow, HDC hdcWindow, int w, int h, PA_PluginParameters params)
{
    if(hbmWindow)
    {
        BITMAPINFO bmpInfo;
        ZeroMemory(&bmpInfo,sizeof(BITMAPINFO));
        bmpInfo.bmiHeader.biSize=sizeof(BITMAPINFOHEADER);
        GetDIBits(hdcWindow, hbmWindow, 0, 0, NULL, &bmpInfo, DIB_RGB_COLORS);
        
        BITMAPINFOHEADER bi;
        bi.biSize = sizeof(BITMAPINFOHEADER);
        bi.biWidth = w;
        bi.biHeight = h;
        bi.biPlanes = 1;
        bi.biBitCount = 32;
        bi.biCompression = BI_RGB;
        bi.biSizeImage = 0;
        bi.biXPelsPerMeter = 0;
        bi.biYPelsPerMeter = 0;
        bi.biClrUsed = 0;
        bi.biClrImportant = 0;
        
        bi.biSizeImage = bmpInfo.bmiHeader.biSizeImage;
        
        HANDLE hDIB = GlobalAlloc(GHND,bi.biSizeImage+sizeof(BITMAPINFOHEADER));
        
        if(hDIB)
        {
            LPBITMAPINFOHEADER lpbi = (LPBITMAPINFOHEADER)GlobalLock(hDIB);
            
            if(lpbi)
            {
                
                *lpbi = bi;
                
                std::vector<char> bits(bi.biSizeImage);
                GetDIBits(hdcWindow, hbmWindow, 0, bi.biHeight, &bits[0], (LPBITMAPINFO)lpbi, DIB_RGB_COLORS);
                
                size_t bfSize            = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) + bi.biSizeImage;
                
                BITMAPFILEHEADER        bmfHeader;
                
                bmfHeader.bfType        = 0x4D42; //BM
                bmfHeader.bfSize        = bfSize;
                bmfHeader.bfReserved1    = 0;
                bmfHeader.bfReserved2    = 0;
                bmfHeader.bfOffBits        = (DWORD)sizeof(BITMAPFILEHEADER) + (DWORD)sizeof(BITMAPINFOHEADER);
                
                std::vector<char> buf(bfSize);
                
                //copy the file header
                memcpy(&buf[0], &bmfHeader, sizeof(BITMAPFILEHEADER));
                //copy the info header and bits
                memcpy(&buf[0] + sizeof(BITMAPFILEHEADER), lpbi, sizeof(BITMAPINFOHEADER));
                //copy the bits
                memcpy(&buf[0] + sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER), &bits[0], lpbi->biSizeImage);
                
                PA_Picture p = PA_CreatePicture((void *)&buf[0], bfSize);
                PA_ReturnPicture(params, p);
                
                GlobalUnlock(hDIB);
            }//GlobalLock
            GlobalFree(hDIB);
        }//GlobalAlloc
        
    }//hbmWindow
    
}
void getWindowImage(HWND windowRef, PA_PluginParameters params)
{
    if(windowRef)
    {
        RECT rect;
        GetWindowRect(windowRef, &rect);
        int w = rect.right - rect.left;
        int h = rect.bottom - rect.top;
        
        HDC        hdcWindow, hdcMemDC;
        HBITMAP    hbmWindow;
        hdcWindow    = GetWindowDC(windowRef);
        if(hdcWindow)
        {
            hdcMemDC    = CreateCompatibleDC(hdcWindow);
            if(hdcMemDC)
            {
                hbmWindow = CreateCompatibleBitmap(hdcWindow, w, h);
                
                if(hbmWindow)
                {
                    HGDIOBJ oldObject = SelectObject(hdcMemDC, hbmWindow);
                    PrintWindow(windowRef, hdcMemDC, 0);
                    BitBlt(hdcMemDC, 0, 0, w, h, hdcWindow, 0, 0, SRCCOPY);
                    
                    captureWindow(hbmWindow, hdcWindow, w, h, params);
                    
                    SelectObject(hdcMemDC, oldObject);
                    DeleteObject(hbmWindow);
                }//CreateCompatibleBitmap
                DeleteDC(hdcMemDC);
            }//CreateCompatibleDC
            DeleteDC(hdcWindow);
        }//CreateDC
        
    }//windowRef
    
}
#endif

void Capture_screen(PA_PluginParameters params) {
    
#if VERSIONMAC
    getWindowImage(kCGNullWindowID, kCGWindowListOptionOnScreenOnly, params);
#else
    getWindowImage(GetDesktopWindow(), params);
#endif

}

void Capture_window(PA_PluginParameters params)
{
    PA_long32 arg1 = PA_GetLongParameter(params, 1);
    
#if VERSIONMAC
    CGWindowID winId = getWindowId(arg1);
    if(winId != kCGNullWindowID)
        getWindowImage(winId, kCGWindowListOptionIncludingWindow, params);
#else
    HWND windowRef = reinterpret_cast<HWND>(PA_GetHWND(reinterpret_cast<PA_WindowRef>(arg1)));
    getWindowImage(windowRef, params);
#endif

}
